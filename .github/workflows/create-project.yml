name: Create Java Reactive Service (Cookiecutter)

on:
  workflow_dispatch:
    inputs:
      repo_name:
        description: "Repo (kebab-case). Ej: customer-api"
        required: true
      service_name:
        description: "Service name (kebab-case). Ej: customer-api"
        required: true
      group_id:
        description: "GroupId. Ej: com.demo"
        required: true
        default: "com.demo"
      base_package:
        description: "Base package. Ej: com.demo.customer"
        required: true
        default: "com.demo.customer"
      visibility:
        description: "private/public"
        required: true
        default: "private"
      port_context:
        required: true
        description: 'Action and general context (blueprint, entity, run id, etc...)'
        type: string

jobs:
  scaffold:
    runs-on: ubuntu-latest
    steps:
      - name: Install cookiecutter
        run: |
          python -m pip install --upgrade pip
          pip install cookiecutter
      - name: Configure git auth for template clone
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        run: |
          git config --global url."https://x-access-token:${GH_TOKEN}@github.com/".insteadOf "https://github.com/"
      - name: Generate project from existing template repo
        run: |
          cookiecutter https://github.com/platform-001/tpl-spring-reactive-openapi.git --no-input \
            repo_name="${{ inputs.repo_name }}" \
            service_name="${{ inputs.service_name }}" \
            group_id="${{ inputs.group_id }}" \
            base_package="${{ inputs.base_package }}"

      - name: Create repo
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        run: |
          REPO="${{ inputs.repo_name }}"
          VIS="${{ inputs.visibility }}"
          gh repo create platform-001/${REPO} --${VIS} --confirm

      - name: Push generated content
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        run: |
          REPO="${{ inputs.repo_name }}"
          cd "${REPO}"

          git init
          git config user.name "platform-bot"
          git config user.email "platform-bot@users.noreply.github.com"

          git add .
          git commit -m "chore: bootstrap ${REPO}"

          git branch -M main
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/platform-001/${REPO}.git"
          git push -u origin main

      - name: Update Port entities + OpenAPI
        env:
          PORT_WEBHOOK_URL: ${{ secrets.PORT_WEBHOOK_URL }}
          REPO: ${{ inputs.repo_name }}
          BRANCH: main
          RUN_URL: https://github.com/platform-001/${{ inputs.repo_name }}/actions
        run: |
          cd "${REPO}"
    
          # Escribimos el script din√°micamente a un archivo temporal
          cat << 'EOF' > report.py
          import json, pathlib, os, requests
          
          repo = os.environ["REPO"]
          branch = os.environ["BRANCH"]
          run_url = os.environ["RUN_URL"]
          webhook_url = os.environ["PORT_WEBHOOK_URL"]
          
          # Lee OpenAPI YAML
          openapi_path = pathlib.Path("api/openapi.yaml")
          open_api = openapi_path.read_text(encoding="utf-8") if openapi_path.exists() else ""
          
          payload = {
              "microservicio": {
                  "cod_servicio": repo,
                  "nombre_servicio": repo,
                  "open_api": open_api,
                  "tecnologia": "Java",
                  "estado_de_aprovisionamiento": "Generado"
              },
              "branch": {
                  "codigo_branch": f"{repo}:{branch}",
                  "build_status": "Con errores",
                  "cobertura": 0,
                  "vulnerabilidades_altas": 0,
                  "secretos_encontrados": 0,
                  "url_pipeline": run_url
              }
          }
          
          print(f"Enviando a Port: {repo}")
          res = requests.post(webhook_url, json=payload)
          res.raise_for_status()
          EOF

          # Ejecutamos el archivo que acabamos de crear
          python3 report.py
      
          # Ahora ejecutamos CURL desde BASH, no desde Python
          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "$PORT_WEBHOOK_URL"
